
BMS_v0.1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  0000020f  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000172  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000016  00803f00  00803f00  00000206  2**0
                  ALLOC
  3 .fuse         00000009  00820000  00820000  00000206  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  0000020f  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000240  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000058  00000000  00000000  0000027c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002027  00000000  00000000  000002d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000016f9  00000000  00000000  000022fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000004da  00000000  00000000  000039f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000a8  00000000  00000000  00003ed0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000124e  00000000  00000000  00003f78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000000a3  00000000  00000000  000051c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000048  00000000  00000000  00005269  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>
  1e:	1a c0       	rjmp	.+52     	; 0x54 <__bad_interrupt>
  20:	19 c0       	rjmp	.+50     	; 0x54 <__bad_interrupt>
  22:	18 c0       	rjmp	.+48     	; 0x54 <__bad_interrupt>
  24:	17 c0       	rjmp	.+46     	; 0x54 <__bad_interrupt>
  26:	16 c0       	rjmp	.+44     	; 0x54 <__bad_interrupt>
  28:	15 c0       	rjmp	.+42     	; 0x54 <__bad_interrupt>
  2a:	14 c0       	rjmp	.+40     	; 0x54 <__bad_interrupt>
  2c:	13 c0       	rjmp	.+38     	; 0x54 <__bad_interrupt>
  2e:	12 c0       	rjmp	.+36     	; 0x54 <__bad_interrupt>
  30:	11 c0       	rjmp	.+34     	; 0x54 <__bad_interrupt>
  32:	10 c0       	rjmp	.+32     	; 0x54 <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	cd bf       	out	0x3d, r28	; 61
  3c:	df e3       	ldi	r29, 0x3F	; 63
  3e:	de bf       	out	0x3e, r29	; 62

00000040 <__do_clear_bss>:
  40:	2f e3       	ldi	r18, 0x3F	; 63
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	bf e3       	ldi	r27, 0x3F	; 63
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a6 31       	cpi	r26, 0x16	; 22
  4c:	b2 07       	cpc	r27, r18
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	70 d0       	rcall	.+224    	; 0x132 <main>
  52:	8d c0       	rjmp	.+282    	; 0x16e <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <ADC0_read_sample>:

#define v_measure_pin (2)

uint16_t ADC0_read_sample(void)
{
	PORTA_OUT |= (1<<v_measure_pin);
  56:	e4 e0       	ldi	r30, 0x04	; 4
  58:	f4 e0       	ldi	r31, 0x04	; 4
  5a:	80 81       	ld	r24, Z
  5c:	84 60       	ori	r24, 0x04	; 4
  5e:	80 83       	st	Z, r24
	
	ADC0.COMMAND = ADC_STCONV_bm;
  60:	81 e0       	ldi	r24, 0x01	; 1
  62:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <__RODATA_PM_OFFSET__+0x7f8608>
	
	while(!(ADC0.INTFLAGS & ADC_RESRDY_bm))
  66:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__RODATA_PM_OFFSET__+0x7f860b>
  6a:	80 ff       	sbrs	r24, 0
  6c:	fc cf       	rjmp	.-8      	; 0x66 <ADC0_read_sample+0x10>
	{
		;
	}
	
	ADC0.INTFLAGS = ADC_RESRDY_bm;
  6e:	e0 e0       	ldi	r30, 0x00	; 0
  70:	f6 e0       	ldi	r31, 0x06	; 6
  72:	81 e0       	ldi	r24, 0x01	; 1
  74:	83 87       	std	Z+11, r24	; 0x0b
	
	PORTA_OUT &= ~(1<<v_measure_pin);
  76:	a4 e0       	ldi	r26, 0x04	; 4
  78:	b4 e0       	ldi	r27, 0x04	; 4
  7a:	8c 91       	ld	r24, X
  7c:	8b 7f       	andi	r24, 0xFB	; 251
  7e:	8c 93       	st	X, r24
	
	return ADC0.RES;
  80:	80 89       	ldd	r24, Z+16	; 0x10
  82:	91 89       	ldd	r25, Z+17	; 0x11
	
}
  84:	08 95       	ret

00000086 <ADC0_init_sample>:

void ADC0_init_sample(void)
{
	PORTA_DIR = (1<<v_measure_pin);	
  86:	e0 e0       	ldi	r30, 0x00	; 0
  88:	f4 e0       	ldi	r31, 0x04	; 4
  8a:	84 e0       	ldi	r24, 0x04	; 4
  8c:	80 83       	st	Z, r24
	
	PORTA.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;  //disable input buffer
  8e:	81 8b       	std	Z+17, r24	; 0x11
	PORTA.PIN1CTRL &= ~PORT_PULLUPEN_bm;   // re-disable pull up
  90:	91 89       	ldd	r25, Z+17	; 0x11
  92:	97 7f       	andi	r25, 0xF7	; 247
  94:	91 8b       	std	Z+17, r25	; 0x11
	
	VREF.CTRLA = VREF_ADC0REFSEL_2V5_gc;   // internal reference to 2.50v
  96:	90 e2       	ldi	r25, 0x20	; 32
  98:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <__RODATA_PM_OFFSET__+0x7f80a0>
	
	ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc; /* ADC Enable: enabled */
  9c:	e0 e0       	ldi	r30, 0x00	; 0
  9e:	f6 e0       	ldi	r31, 0x06	; 6
  a0:	91 e0       	ldi	r25, 0x01	; 1
  a2:	90 83       	st	Z, r25
	
	ADC0.CTRLC = ADC_REFSEL_INTREF_gc | ADC_PRESC_DIV4_gc ;    // internal reference and clock divided by 5
  a4:	92 83       	std	Z+2, r25	; 0x02
	
	ADC0.MUXPOS = ADC_MUXPOS_AIN1_gc; // on pin pa1
  a6:	96 83       	std	Z+6, r25	; 0x06
	
	ADC0.CTRLB = ADC_SAMPNUM_ACC16_gc; // 16 samples
  a8:	81 83       	std	Z+1, r24	; 0x01
  aa:	08 95       	ret

000000ac <USART0_init>:



void USART0_init(void)
{
	PORTB_DIR |= PIN2_bm;       // Tx - Output(1)
  ac:	e0 e2       	ldi	r30, 0x20	; 32
  ae:	f4 e0       	ldi	r31, 0x04	; 4
  b0:	80 81       	ld	r24, Z
  b2:	84 60       	ori	r24, 0x04	; 4
  b4:	80 83       	st	Z, r24
	//PORTB_DIR &= ~PIN3_bm;	// Rx - Input(0)
	
	USART0.BAUD =(uint16_t)USART0_BAUD_RATE(9600);
  b6:	e0 e0       	ldi	r30, 0x00	; 0
  b8:	f8 e0       	ldi	r31, 0x08	; 8
  ba:	87 e5       	ldi	r24, 0x57	; 87
  bc:	94 e0       	ldi	r25, 0x04	; 4
  be:	80 87       	std	Z+8, r24	; 0x08
  c0:	91 87       	std	Z+9, r25	; 0x09
	
	USART0.CTRLB |= USART_TXEN_bm; //enabling the transmit line
  c2:	86 81       	ldd	r24, Z+6	; 0x06
  c4:	80 64       	ori	r24, 0x40	; 64
  c6:	86 83       	std	Z+6, r24	; 0x06
  c8:	08 95       	ret

000000ca <USART0_sendChar>:
	
}

void USART0_sendChar(uint16_t c)
{
	while(!(USART0.STATUS & USART_DREIE_bm))
  ca:	90 91 04 08 	lds	r25, 0x0804	; 0x800804 <__RODATA_PM_OFFSET__+0x7f8804>
  ce:	95 ff       	sbrs	r25, 5
  d0:	fc cf       	rjmp	.-8      	; 0xca <USART0_sendChar>
	{
		;
	}
	USART0.TXDATAL = c;
  d2:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__RODATA_PM_OFFSET__+0x7f8802>
  d6:	08 95       	ret

000000d8 <USART0_sendString>:
}

void USART0_sendString(uint8_t *str)
{
  d8:	0f 93       	push	r16
  da:	1f 93       	push	r17
  dc:	cf 93       	push	r28
  de:	df 93       	push	r29
  e0:	8c 01       	movw	r16, r24
	/*for(size_t i = 0;i <strlen(str); i++)
	{
		USART0_sendChar(str[i]);
	}
	*/
	for(size_t i = 0;i < 6; i++)
  e2:	c0 e0       	ldi	r28, 0x00	; 0
  e4:	d0 e0       	ldi	r29, 0x00	; 0
  e6:	07 c0       	rjmp	.+14     	; 0xf6 <USART0_sendString+0x1e>
	{
		USART0_sendChar(str[i]);
  e8:	f8 01       	movw	r30, r16
  ea:	ec 0f       	add	r30, r28
  ec:	fd 1f       	adc	r31, r29
  ee:	80 81       	ld	r24, Z
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	eb df       	rcall	.-42     	; 0xca <USART0_sendChar>
	/*for(size_t i = 0;i <strlen(str); i++)
	{
		USART0_sendChar(str[i]);
	}
	*/
	for(size_t i = 0;i < 6; i++)
  f4:	21 96       	adiw	r28, 0x01	; 1
  f6:	c6 30       	cpi	r28, 0x06	; 6
  f8:	d1 05       	cpc	r29, r1
  fa:	b0 f3       	brcs	.-20     	; 0xe8 <USART0_sendString+0x10>
	{
		USART0_sendChar(str[i]);
	}
}
  fc:	df 91       	pop	r29
  fe:	cf 91       	pop	r28
 100:	1f 91       	pop	r17
 102:	0f 91       	pop	r16
 104:	08 95       	ret

00000106 <low_power_init>:
{
	//PORTA_DIR = 0xff; // all pins as output to save power
	
	//PORTA.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc; //UPDI
	//PORTA.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc; //Analog in
	PORTA.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;   // digital out to adc
 106:	e0 e0       	ldi	r30, 0x00	; 0
 108:	f4 e0       	ldi	r31, 0x04	; 4
 10a:	84 e0       	ldi	r24, 0x04	; 4
 10c:	82 8b       	std	Z+18, r24	; 0x12
	PORTA.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
 10e:	83 8b       	std	Z+19, r24	; 0x13
	PORTA.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;	
 110:	84 8b       	std	Z+20, r24	; 0x14
	PORTA.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
 112:	85 8b       	std	Z+21, r24	; 0x15
	PORTA.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;	
 114:	86 8b       	std	Z+22, r24	; 0x16
	PORTA.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;	
 116:	87 8b       	std	Z+23, r24	; 0x17
	
	PORTB.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
 118:	e0 e2       	ldi	r30, 0x20	; 32
 11a:	f4 e0       	ldi	r31, 0x04	; 4
 11c:	80 8b       	std	Z+16, r24	; 0x10
	PORTB.PIN1CTRL = PORT_ISC_INPUT_DISABLE_gc;
 11e:	81 8b       	std	Z+17, r24	; 0x11
 120:	08 95       	ret

00000122 <onPacketReceived>:

uint8_t SerialPacketReceiveBuffer[8+ sizeof(dataBuffer)];

void onPacketReceived(dataBuffer *receivebuffer)
{
	receivebuffer->address =2;
 122:	22 e0       	ldi	r18, 0x02	; 2
 124:	fc 01       	movw	r30, r24
 126:	20 83       	st	Z, r18
	//receivebuffer->test =2;
	receivebuffer->value[1] = 900;
 128:	24 e8       	ldi	r18, 0x84	; 132
 12a:	33 e0       	ldi	r19, 0x03	; 3
 12c:	24 83       	std	Z+4, r18	; 0x04
 12e:	35 83       	std	Z+5, r19	; 0x05
 130:	08 95       	ret

00000132 <main>:
}

int main(void)
{
	
	low_power_init();
 132:	e9 df       	rcall	.-46     	; 0x106 <low_power_init>
  	USART0_init();
 134:	bb df       	rcall	.-138    	; 0xac <USART0_init>
  	ADC0_init_sample();
 136:	a7 df       	rcall	.-178    	; 0x86 <ADC0_init_sample>
	
	while (1)
  	{
		
	  	adcVal = ADC0_read_sample();
 138:	8e df       	rcall	.-228    	; 0x56 <ADC0_read_sample>
	  	
	  	adcVal = adcVal >> 4;
 13a:	92 95       	swap	r25
 13c:	82 95       	swap	r24
 13e:	8f 70       	andi	r24, 0x0F	; 15
 140:	89 27       	eor	r24, r25
 142:	9f 70       	andi	r25, 0x0F	; 15
 144:	89 27       	eor	r24, r25
 146:	80 93 14 3f 	sts	0x3F14, r24	; 0x803f14 <adcVal>
 14a:	90 93 15 3f 	sts	0x3F15, r25	; 0x803f15 <adcVal+0x1>
		  
		 // adcdata +=1;
		  
		 // *adcdata = 5;
		//sprintf("%i\r\n" , adcVal);  //takes up huge chunk of code space.
		onPacketReceived((dataBuffer*)SerialPacketReceiveBuffer);
 14e:	86 e0       	ldi	r24, 0x06	; 6
 150:	9f e3       	ldi	r25, 0x3F	; 63
 152:	e7 df       	rcall	.-50     	; 0x122 <onPacketReceived>
		
	  	USART0_sendString(SerialPacketReceiveBuffer);
 154:	86 e0       	ldi	r24, 0x06	; 6
 156:	9f e3       	ldi	r25, 0x3F	; 63
 158:	bf df       	rcall	.-130    	; 0xd8 <USART0_sendString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 15a:	24 e5       	ldi	r18, 0x54	; 84
 15c:	83 e2       	ldi	r24, 0x23	; 35
 15e:	98 e0       	ldi	r25, 0x08	; 8
 160:	21 50       	subi	r18, 0x01	; 1
 162:	80 40       	sbci	r24, 0x00	; 0
 164:	90 40       	sbci	r25, 0x00	; 0
 166:	e1 f7       	brne	.-8      	; 0x160 <main+0x2e>
 168:	00 c0       	rjmp	.+0      	; 0x16a <main+0x38>
 16a:	00 c0       	rjmp	.+0      	; 0x16c <main+0x3a>
 16c:	e5 cf       	rjmp	.-54     	; 0x138 <main+0x6>

0000016e <_exit>:
 16e:	f8 94       	cli

00000170 <__stop_program>:
 170:	ff cf       	rjmp	.-2      	; 0x170 <__stop_program>
